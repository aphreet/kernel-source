From: Pavel Tatashin <pasha.tatashin@oracle.com>
Subject: mm-adaptive-hash-table-scaling-v5
Patch-mainline: not yet, mmotm tree (4.12+ expected)
References: bnc#1036303

Disable adaptive hash on 32 bit systems to avoid confusion of whether base
should be different for smaller systems, and to avoid overflows.

Link: http://lkml.kernel.org/r/1495469329-755807-2-git-send-email-pasha.tatashin@oracle.com
Signed-off-by: Pavel Tatashin <pasha.tatashin@oracle.com>
Cc: David Miller <davem@davemloft.net>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Babu Moger <babu.moger@oracle.com>
Cc: Stephen Rothwell <sfr@canb.auug.org.au>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Acked-by: Michal Hocko <mhocko@suse.cz>

---

 mm/page_alloc.c |    4 ++++
 1 file changed, 4 insertions(+)

--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -6705,9 +6705,11 @@ __setup("hashdist=", set_hashdist);
  * quadruples the scale is increased by one, which means the size of hash table
  * only doubles, instead of quadrupling as well.
  */
+#if __BITS_PER_LONG > 32
 #define ADAPT_SCALE_BASE	(64ul << 30)
 #define ADAPT_SCALE_SHIFT	2
 #define ADAPT_SCALE_NPAGES	(ADAPT_SCALE_BASE >> PAGE_SHIFT)
+#endif
 
 /*
  * allocate a large system hash table from bootmem
@@ -6738,6 +6740,7 @@ void *__init alloc_large_system_hash(con
 		if (PAGE_SHIFT < 20)
 			numentries = round_up(numentries, (1<<20)/PAGE_SIZE);
 
+#if __BITS_PER_LONG > 32
 		if (flags & HASH_ADAPT) {
 			unsigned long adapt;
 
@@ -6745,6 +6748,7 @@ void *__init alloc_large_system_hash(con
 			     adapt <<= ADAPT_SCALE_SHIFT)
 				scale++;
 		}
+#endif
 
 		/* limit to 1 bucket per 2^scale bytes of low memory */
 		if (scale > PAGE_SHIFT)
