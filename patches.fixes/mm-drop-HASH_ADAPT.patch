From 82ab38428bcc028ff2aab2ed807a0caf8b7b7c68 Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.com>
Date: Tue, 9 May 2017 11:34:59 +0200
Subject: [PATCH] mm: drop HASH_ADAPT
Patch-mainline: not yet, pending for mmotm (4.12+)
References: bnc#1036303

mhocko@suse.com:
upstream 9017217b6f45 ("mm: adaptive hash table scaling") didn't introduce
HASH_ADAPT in the end so this is not really needed.

"mm: Adaptive hash table scaling" has introduced a new large hash table
automatic scaling because the previous implementation led to too large
hashes on TB systems. This is all nice and good but the patch assumes that
callers of alloc_large_system_hash will opt-in to use this new scaling.
This makes the API unnecessarily complicated and error prone. The only
thing that callers should care about is whether they have an upper
bound for the size or leave it to alloc_large_system_hash to decide (by
providing high_limit == 0).

As a quick code inspection shows there are users with high_limit == 0
which do not use the flag already e.g. {dcache,inode}_init_early or
mnt_init when creating mnt has tables. They certainly have no good
reason to use a different scaling because the [di]cache was the
motivation for introducing a different scaling in the first place (we
just do this attempt and use memblock). It is also hard to imagine why
we would mnt hash tables need larger hash tables.

Just drop the flag and use the scaling whenever there is no high_limit
specified.

Reviewed-by: Pavel Tatashin <pasha.tatashin@oracle.com>
Signed-off-by: Michal Hocko <mhocko@suse.com>

---
 fs/dcache.c             |    2 +-
 fs/inode.c              |    2 +-
 include/linux/bootmem.h |    1 -
 mm/page_alloc.c         |    2 +-
 4 files changed, 3 insertions(+), 4 deletions(-)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -3425,7 +3425,7 @@ static void __init dcache_init(void)
 					sizeof(struct hlist_bl_head),
 					dhash_entries,
 					13,
-					HASH_ADAPT,
+					0,
 					&d_hash_shift,
 					&d_hash_mask,
 					0,
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -1895,7 +1895,7 @@ void __init inode_init(void)
 					sizeof(struct hlist_head),
 					ihash_entries,
 					14,
-					HASH_ADAPT,
+					0,
 					&i_hash_shift,
 					&i_hash_mask,
 					0,
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@ -353,7 +353,6 @@ extern void *alloc_large_system_hash(con
 #define HASH_EARLY	0x00000001	/* Allocating during early boot? */
 #define HASH_SMALL	0x00000002	/* sub-page allocation allowed, min
 					 * shift passed via *_hash_shift */
-#define	HASH_ADAPT	0x00000008	/* Adaptive scale for large memory */
 
 /* Only NUMA needs hash distribution. 64bit NUMA architectures have
  * sufficient vmalloc space.
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -6741,7 +6741,7 @@ void *__init alloc_large_system_hash(con
 			numentries = round_up(numentries, (1<<20)/PAGE_SIZE);
 
 #if __BITS_PER_LONG > 32
-		if (flags & HASH_ADAPT) {
+		if (!high_limit) {
 			unsigned long adapt;
 
 			for (adapt = ADAPT_SCALE_NPAGES; adapt < numentries;
