From: Joerg Roedel <jroedel@suse.de>
Subject: Fix kABI breakage by KVM CVE fix
Patch-mainline: Never, kabi
References: bsc#1045922

The patch
  patches.fixes/kvm-x86-fix-singlestepping-over-syscall
breaks kABI due to the introduction of tf to the emulation
context field.
This patch moves the new bool flag to the existing
emul_flags member to avoid the new member.

Signed-off-by: Joerg Roedel <jroedel@suse.de>

---
 include/asm/kvm_emulate.h |    2 +-
 kvm/emulate.c             |    4 +++-
 kvm/x86.c                 |    9 ++++++---
 3 files changed, 10 insertions(+), 5 deletions(-)

--- a/arch/x86/include/asm/kvm_emulate.h
+++ b/arch/x86/include/asm/kvm_emulate.h
@@ -278,6 +278,7 @@ enum x86emul_mode {
 #define X86EMUL_GUEST_MASK           (1 << 5) /* VCPU is in guest-mode */
 #define X86EMUL_SMM_MASK             (1 << 6)
 #define X86EMUL_SMM_INSIDE_NMI_MASK  (1 << 7)
+#define X86EMUL_TF_BEFORE_INST	     (1 << 8) /* TF value before instruction (after for syscall/sysret) */
 
 struct x86_emulate_ctxt {
 	const struct x86_emulate_ops *ops;
@@ -294,7 +295,6 @@ struct x86_emulate_ctxt {
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn't support insn */
-	bool tf;	/* TF value before instruction (after for syscall/sysret) */
 
 	bool have_exception;
 	struct x86_exception exception;
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -2726,7 +2726,9 @@ static int em_syscall(struct x86_emulate
 		ctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);
 	}
 
-	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;
+	if ((ctxt->eflags & X86_EFLAGS_TF) != 0)
+		ctxt->emul_flags |= X86EMUL_TF_BEFORE_INST;
+
 	return X86EMUL_CONTINUE;
 }
 
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5084,8 +5084,6 @@ static void init_emulate_ctxt(struct kvm
 	kvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);
 
 	ctxt->eflags = kvm_get_rflags(vcpu);
-	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;
-
 	ctxt->eip = kvm_rip_read(vcpu);
 	ctxt->mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :
 		     (ctxt->eflags & X86_EFLAGS_VM)	? X86EMUL_MODE_VM86 :
@@ -5096,6 +5094,8 @@ static void init_emulate_ctxt(struct kvm
 	BUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);
 	BUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);
 	ctxt->emul_flags = vcpu->arch.hflags;
+	if ((ctxt->eflags & X86_EFLAGS_TF) != 0)
+		ctxt->emul_flags |= X86EMUL_TF_BEFORE_INST;
 
 	init_decode_cache(ctxt);
 	vcpu->arch.emulate_regs_need_sync_from_vcpu = false;
@@ -5477,13 +5477,16 @@ restart:
 
 	if (writeback) {
 		unsigned long rflags = kvm_x86_ops->get_rflags(vcpu);
+		bool tf = ctxt->emul_flags & X86EMUL_TF_BEFORE_INST;
+
+		ctxt->emul_flags &= ~X86EMUL_TF_BEFORE_INST;
 		toggle_interruptibility(vcpu, ctxt->interruptibility);
 		vcpu->arch.emulate_regs_need_sync_to_vcpu = false;
 		if (vcpu->arch.hflags != ctxt->emul_flags)
 			kvm_set_hflags(vcpu, ctxt->emul_flags);
 		kvm_rip_write(vcpu, ctxt->eip);
 		if (r == EMULATE_DONE &&
-		    (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))
+		    (tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))
 			kvm_vcpu_do_singlestep(vcpu, &r);
 		if (!ctxt->have_exception ||
 		    exception_type(ctxt->exception.vector) == EXCPT_TRAP)
